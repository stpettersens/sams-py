#!/usr/bin/python
"""
Automaton
Scriptable host interaction client
Copyright (c) 2010 Sam Saint-Pettersen

Released under the MIT License.
"""
import sys
import os
import getopt
import socket
import signal
import json
import uuid
import datetime
import re
import Queue

class AIS_Command:
	pass
	
class AIS_Engine:
    """
    Script engine to execute commands in a script
    """
    def parse(self, command):
        return 'a'
	
class ScriptLoader:
	"""
	Script loader to execute a script on host machine
	"""	
	def __init__(self, conn, debug):
	    """
	    Initialization method for script thread
	    """
	    self.debug = debug 
	    self.conn = conn
		
	def execute(self, script):
		print('Executing \'{script}\'...\n'.format(script=script))
		
		# Read script file line-by-line, parse each command in file
		engine = AIS_Engine()
		x = engine.parse('pineapple')
		
		print('Done.')
		
class Connection:
	"""
	Connection class to connect to target host
    (One and only instance)
	"""
	def __init__(self, debug, host, port, script):
		"""
		Initialization method for connection thread
		"""
		self.debug = debug
		self.host = host
		self.port = port
		self.script = script
		self.connectQueue()
		
	def connectQueue(self):
		"""
		Connect to target host and queue and parse on scripts to script loader
		"""
		print('\nConnecting to {0}:{1}...'.format(self.host, self.port))
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect((self.host, self.port))
		
		scriptLoader = ScriptLoader(s, self.debug)
		scriptLoader.execute(self.script) #!
		
		
			
		#s.close()
				
class Automaton:
	"""
	Automation instance class
	(One and only instance)
	"""
	def __init__(self):
		"""
		Initialization method for Automation
		"""
		# Application information
		self.Name = 'Automaton'
		self.Vers = '1.0'
		#
		self.Config = 'automation.conf.json'
		self.termSig = False # Termination control variable
		
		# Configuration to use:
		#  x signature (default: autogenerated uuid)
		# -h hostname (default: 'localhost')
		# -p port num.(default: 8282)
		# -d use debug (default: False)
		# -s script(s) (default: 'do_not_change')
		config = ({
		'x':'{sig}'.format(sig=uuid.uuid4()), '-h':'localhost', '-p':8282, '-d':False,
		'-s':'do_not_change'
		})
		
		methods = ({
		'-i':'displayCmdLineOps()', '-v':'displayInfo()'
		})
		
		# Allow configuration file to overwrite defaults
		config = self.handleConfig(config, 'r')
		
		# Handle command line options
		opts, args = getopt.getopt(sys.argv[1:],'ivbch:p:s:')
		for o, a in opts:
			print(a)
			if a != '': config[o] = str(a)
			else: eval('self.{method}'.format(method=methods.get(0)))

		print(__doc__)
		print('Hold Ctrl-C to terminate.')
		Connection(config.get('d'), config.get('-h'), int(config.get('-p')), config.get('-s'))
		while not self.termSig:
			signal.signal(signal.SIGINT, self.quit)
			if self.termSig: break
		sys.exit(0)
			
	def displayCmdLineOps(self):
		"""
		Display command line options
		"""
		print(__doc__)
		print('Usage: {program} [-i][-v][-b][-c]'.format(program=sys.argv[0])
		+ '\n[-d -h <hostname> -p <port number> -s <script+(script+)>\n')
		print('-i: Display this information.')
		print('-v: Display versio information and signature.')	
		print('-b: Display built-in commands.')
		print('-c: Display defined commands and variables.')
		print('-d: Display debug information while running.')
		print('-h: Hostname to connect to. (\'{host}\' if omitted)'.format(host='localhost'))
		print('-p: Listen on specified port number. ({port} if omitted)'.format(port=8282))
		print('-s: Script(s) to execute; *.ais file(s). (Mandatory arg)')
		sys.exit(0)

	def	displayInfo(self):
	    print('{app} {ver} ({plat}/{os})'
		.format(app=self.Name, ver=self.Vers, plat=sys.platform, os=os.name))
		#print('Security signature: {sig}'.format(sig=config.get('x'))
	    sys.exit(0)
		
	def handleConfig(self, config, rw):
		try:
			if rw == 'r': 
				config = json.load(open(self.Config, 'r'))
				return config

			elif rw == 'w':
				json.dump(config, open(self.Config, 'w'))
			
		except IOError:
			json.dump(config, open(self.Config, 'w'))

	def quit(self, signum, frame):
		print('\nClient terminated.\n')
		self.termSig = True

if __name__ == '__main__': Automaton()
